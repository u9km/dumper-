name: Build From 4 Zips (Auto Scan + Fix)

on:
  push:
    branches: ["**"]
  workflow_dispatch:

jobs:
  build:
    runs-on: macos-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      # 1) Unzip all zip files recursively (NO mapfile; works on bash 3.2)
      - name: 1) Unzip ALL zip files (recursive) + show paths
        shell: bash
        run: |
          set -euo pipefail

          echo "üîé Searching for .zip files anywhere..."
          # find all zips in repo (including nested) and unzip into a single workspace folder
          rm -rf _extract
          mkdir -p _extract

          # unzip each zip into a subfolder named after the zip (safe, no collisions)
          find . -type f -name "*.zip" -print | while IFS= read -r z; do
            base="$(basename "$z" .zip)"
            out="_extract/$base"
            echo "üì¶ Unzipping: $z  -->  $out"
            mkdir -p "$out"
            unzip -o -q "$z" -d "$out"
          done

          echo ""
          echo "‚úÖ Extracted roots:"
          ls -la _extract || true

          echo ""
          echo "üß≠ Listing top-level structure (2 levels) to prove everything exists:"
          find _extract -maxdepth 2 -type d -print | sed 's|^|DIR: |'

          echo ""
          echo "üìÑ Showing key files (Makefile / *.mm / *.xm / KittyInclude.hpp / fmt headers):"
          find _extract -type f \( -name "Makefile" -o -name "*.mm" -o -name "*.xm" -o -name "KittyInclude.hpp" -o -path "*fmt/format.h" \) -print | sed 's|^|FILE: |' || true

      # 2) Locate project root by Makefile (Theos project)
      - name: 2) Locate PROJECT_ROOT (Makefile) + locate deps (KittyMemory) + locate sources
        shell: bash
        run: |
          set -euo pipefail

          echo "üîç Searching for Makefile in extracted content..."
          MAKEFILE_PATH="$(find _extract -type f -name "Makefile" | head -n 1 || true)"
          if [ -z "${MAKEFILE_PATH:-}" ]; then
            echo "‚ùå ERROR: No Makefile found inside extracted zips."
            exit 1
          fi

          PROJECT_ROOT="$(cd "$(dirname "$MAKEFILE_PATH")" && pwd)"
          echo "‚úÖ PROJECT_ROOT = $PROJECT_ROOT"
          echo "PROJECT_ROOT=$PROJECT_ROOT" >> "$GITHUB_ENV"

          echo ""
          echo "üîç Searching for KittyInclude.hpp..."
          KITTY_HDR="$(find _extract -type f -name "KittyInclude.hpp" | head -n 1 || true)"
          if [ -n "${KITTY_HDR:-}" ]; then
            echo "‚úÖ Found KittyInclude.hpp at: $KITTY_HDR"
            KITTY_INC_DIR="$(cd "$(dirname "$KITTY_HDR")" && pwd)"
            echo "‚úÖ KITTY_INC_DIR = $KITTY_INC_DIR"
            echo "KITTY_INC_DIR=$KITTY_INC_DIR" >> "$GITHUB_ENV"
          else
            echo "‚ö†Ô∏è KittyInclude.hpp not found in zips."
            echo "KITTY_INC_DIR=" >> "$GITHUB_ENV"
          fi

          echo ""
          echo "üîç Searching for tweak sources (*.xm / *.mm / *.m) in PROJECT_ROOT..."
          find "$PROJECT_ROOT" -type f \( -name "*.xm" -o -name "*.mm" -o -name "*.m" \) -print | sed 's|^|SRC: |' || true

      # 3) Setup Theos (clean) + FIX sdks conflict + install deps (fmt, ldid, xz)
      - name: 3) Setup Theos (clean) + FIX sdks conflict
        shell: bash
        run: |
          set -euo pipefail

          echo "üßπ Removing old Theos to avoid conflicts..."
          rm -rf "$HOME/theos"

          echo "‚¨áÔ∏è Cloning Theos..."
          git clone --recursive --depth=1 https://github.com/theos/theos.git "$HOME/theos"

          echo "THEOS=$HOME/theos" >> "$GITHUB_ENV"
          echo "$HOME/theos/bin" >> "$GITHUB_PATH"

          echo "‚¨áÔ∏è Installing SDKs (clean, no 'already exists' error)..."
          rm -rf "$HOME/theos/sdks"
          git clone --depth=1 https://github.com/theos/sdks.git "$HOME/theos/sdks"

          echo "üßΩ Optional: remove very old SDKs to reduce size..."
          rm -rf "$HOME/theos/sdks/iPhoneOS"{9,10,11,12,13}.sdk || true

          echo "üç∫ Installing build tools + fmt..."
          brew update
          brew install ldid xz fmt

          echo "‚úÖ Theos + deps ready."

      # 3.1) Ensure KittyMemory exists (fallback clone) and place it in PROJECT_ROOT/deps/KittyMemory
      - name: 3.1) Ensure KittyMemory exists (fallback clone)
        shell: bash
        run: |
          set -euo pipefail
          cd "$PROJECT_ROOT"

          mkdir -p deps

          if [ -n "${KITTY_INC_DIR:-}" ]; then
            echo "üì¶ Using KittyMemory from extracted zips..."
            # We want deps/KittyMemory to contain KittyInclude.hpp somewhere inside.
            rm -rf deps/KittyMemory
            mkdir -p deps/KittyMemory
            # copy the parent folder of include dir to keep structure
            # if KITTY_INC_DIR ends with /KittyMemory then copy it, else copy that folder content
            parent="$(basename "$KITTY_INC_DIR")"
            if [ "$parent" = "KittyMemory" ]; then
              cp -R "$KITTY_INC_DIR" deps/KittyMemory
            else
              cp -R "$KITTY_INC_DIR" deps/KittyMemory/
            fi
          else
            echo "‚¨áÔ∏è Cloning KittyMemory fallback into PROJECT_ROOT/deps/KittyMemory ..."
            rm -rf deps/KittyMemory
            git clone --depth=1 https://github.com/MJx0/KittyMemory.git deps/KittyMemory
          fi

          echo "üîé Verifying KittyInclude.hpp..."
          FOUND_KITTY="$(find deps/KittyMemory -type f -name "KittyInclude.hpp" | head -n 1 || true)"
          if [ -z "${FOUND_KITTY:-}" ]; then
            echo "‚ùå ERROR: KittyInclude.hpp still not found in deps/KittyMemory"
            echo "üìÇ Listing deps/KittyMemory:"
            find deps/KittyMemory -maxdepth 4 -type d -print
            exit 1
          fi

          echo "‚úÖ Found KittyInclude.hpp at: $FOUND_KITTY"
          KITTY_INC_LOCAL="$(cd "$(dirname "$FOUND_KITTY")" && pwd)"
          echo "KITTY_INC_LOCAL=$KITTY_INC_LOCAL" >> "$GITHUB_ENV"

      # 3.2) Auto-fix Makefile if it references a missing source file (e.g. UEDumper.mm not present)
      - name: 3.2) Auto-fix Makefile (missing source file like UEDumper.mm)
        shell: bash
        run: |
          set -euo pipefail
          cd "$PROJECT_ROOT"

          echo "üß© Checking Makefile for missing *_FILES entries..."
          if [ ! -f Makefile ]; then
            echo "‚ùå ERROR: Makefile not found in PROJECT_ROOT"
            exit 1
          fi

          echo "üîé Candidate sources in project:"
          find . -maxdepth 3 -type f \( -name "*.xm" -o -name "*.mm" -o -name "*.m" \) -print | sed 's|^|CAND: |' || true

          # pick a "main" source file if exists
          MAIN_SRC="$(find . -maxdepth 3 -type f \( -name "*.xm" -o -name "*.mm" \) | head -n 1 || true)"
          if [ -z "${MAIN_SRC:-}" ]; then
            MAIN_SRC="$(find . -maxdepth 3 -type f -name "*.m" | head -n 1 || true)"
          fi
          if [ -z "${MAIN_SRC:-}" ]; then
            echo "‚ùå ERROR: No source files (*.xm/*.mm/*.m) found to build."
            exit 1
          fi
          # normalize to relative path without leading ./
          MAIN_SRC="${MAIN_SRC#./}"
          echo "‚úÖ Selected MAIN_SRC = $MAIN_SRC"

          # If Makefile contains a *_FILES line referencing a non-existing file, replace that token with MAIN_SRC.
          # This fixes: "Error: File UEDumper.mm does not exist."
          # We'll scan all tokens that end with .mm/.xm/.m and replace only those that don't exist.
          FILE_TOKENS="$(grep -E '^[A-Za-z0-9_]+\_FILES\s*\+?=' Makefile | sed 's/.*=\s*//' | tr ' ' '\n' | grep -E '\.(mm|xm|m)$' || true)"

          if [ -n "${FILE_TOKENS:-}" ]; then
            echo "$FILE_TOKENS" | while IFS= read -r tok; do
              # strip possible trailing backslashes
              t="${tok%\\}"
              if [ ! -f "$t" ]; then
                echo "üõ† Missing in Makefile: $t  -> replacing with $MAIN_SRC"
                # replace exact token occurrences
                perl -0777 -i -pe "s/\b\Q$t\E\b/$MAIN_SRC/g" Makefile
              else
                echo "‚úÖ Exists: $t"
              fi
            done
          else
            echo "‚ÑπÔ∏è No *_FILES tokens detected (or Makefile format differs). Skipping token patch."
          fi

          echo ""
          echo "üìÑ Final Makefile *_FILES lines:"
          grep -nE '^[A-Za-z0-9_]+\_FILES' Makefile || true

      # 4) Build with auto include paths for KittyMemory + fmt
      - name: 4) Build (auto include paths for KittyMemory + fmt)
        shell: bash
        run: |
          set -euo pipefail
          cd "$PROJECT_ROOT"

          echo "üîß Detecting Kitty include directory..."
          # prefer the verified local include path
          KITTY_INC="${KITTY_INC_LOCAL:-}"
          if [ -z "${KITTY_INC:-}" ]; then
            # fallback: find again
            FOUND_KITTY="$(find deps/KittyMemory -type f -name "KittyInclude.hpp" | head -n 1 || true)"
            if [ -n "${FOUND_KITTY:-}" ]; then
              KITTY_INC="$(cd "$(dirname "$FOUND_KITTY")" && pwd)"
            fi
          fi

          if [ -z "${KITTY_INC:-}" ]; then
            echo "‚ùå ERROR: Cannot locate Kitty include directory."
            exit 1
          fi

          echo "‚úÖ KITTY_INC = $KITTY_INC"

          echo "üîß Detecting fmt include/lib..."
          FMT_PREFIX="$(brew --prefix fmt)"
          echo "‚úÖ FMT_PREFIX = $FMT_PREFIX"

          INC_FLAGS="-I$KITTY_INC -I$FMT_PREFIX/include"
          LIB_FLAGS="-L$FMT_PREFIX/lib -lfmt"

          echo ""
          echo "‚úÖ Using include flags: $INC_FLAGS"
          echo "‚úÖ Using lib flags:     $LIB_FLAGS"

          echo ""
          echo "üßº Cleaning..."
          make clean || true

          echo "üöÄ Building package..."
          # Pass include + link flags in the standard Theos variables
          make package FINALPACKAGE=1 messages=yes \
            THEOS_PACKAGE_SCHEME=rootless \
            ADDITIONAL_CFLAGS="$INC_FLAGS" \
            ADDITIONAL_CCFLAGS="$INC_FLAGS" \
            ADDITIONAL_CXXFLAGS="$INC_FLAGS" \
            ADDITIONAL_LDFLAGS="$LIB_FLAGS"

      - name: 5) Upload DEB
        uses: actions/upload-artifact@v4
        with:
          name: UEDumper_Build_DEB
          path: ${{ env.PROJECT_ROOT }}/packages/*.deb
          if-no-files-found: error
